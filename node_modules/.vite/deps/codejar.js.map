{
  "version": 3,
  "sources": ["../../codejar/codejar.js"],
  "sourcesContent": ["const globalWindow = window;\nexport function CodeJar(editor, highlight, opt = {}) {\n    const options = Object.assign({ tab: '\\t', indentOn: /[({\\[]$/, moveToNewLine: /^[)}\\]]/, spellcheck: false, catchTab: true, preserveIdent: true, addClosing: true, history: true, window: globalWindow }, opt);\n    const window = options.window;\n    const document = window.document;\n    let listeners = [];\n    let history = [];\n    let at = -1;\n    let focus = false;\n    let callback;\n    let prev; // code content prior keydown event\n    editor.setAttribute('contenteditable', 'plaintext-only');\n    editor.setAttribute('spellcheck', options.spellcheck ? 'true' : 'false');\n    editor.style.outline = 'none';\n    editor.style.overflowWrap = 'break-word';\n    editor.style.overflowY = 'auto';\n    editor.style.whiteSpace = 'pre-wrap';\n    let isLegacy = false; // true if plaintext-only is not supported\n    highlight(editor);\n    if (editor.contentEditable !== 'plaintext-only')\n        isLegacy = true;\n    if (isLegacy)\n        editor.setAttribute('contenteditable', 'true');\n    const debounceHighlight = debounce(() => {\n        const pos = save();\n        highlight(editor, pos);\n        restore(pos);\n    }, 30);\n    let recording = false;\n    const shouldRecord = (event) => {\n        return !isUndo(event) && !isRedo(event)\n            && event.key !== 'Meta'\n            && event.key !== 'Control'\n            && event.key !== 'Alt'\n            && !event.key.startsWith('Arrow');\n    };\n    const debounceRecordHistory = debounce((event) => {\n        if (shouldRecord(event)) {\n            recordHistory();\n            recording = false;\n        }\n    }, 300);\n    const on = (type, fn) => {\n        listeners.push([type, fn]);\n        editor.addEventListener(type, fn);\n    };\n    on('keydown', event => {\n        if (event.defaultPrevented)\n            return;\n        prev = toString();\n        if (options.preserveIdent)\n            handleNewLine(event);\n        else\n            legacyNewLineFix(event);\n        if (options.catchTab)\n            handleTabCharacters(event);\n        if (options.addClosing)\n            handleSelfClosingCharacters(event);\n        if (options.history) {\n            handleUndoRedo(event);\n            if (shouldRecord(event) && !recording) {\n                recordHistory();\n                recording = true;\n            }\n        }\n        if (isLegacy && !isCopy(event))\n            restore(save());\n    });\n    on('keyup', event => {\n        if (event.defaultPrevented)\n            return;\n        if (event.isComposing)\n            return;\n        if (prev !== toString())\n            debounceHighlight();\n        debounceRecordHistory(event);\n        if (callback)\n            callback(toString());\n    });\n    on('focus', _event => {\n        focus = true;\n    });\n    on('blur', _event => {\n        focus = false;\n    });\n    on('paste', event => {\n        recordHistory();\n        handlePaste(event);\n        recordHistory();\n        if (callback)\n            callback(toString());\n    });\n    function save() {\n        const s = getSelection();\n        const pos = { start: 0, end: 0, dir: undefined };\n        let { anchorNode, anchorOffset, focusNode, focusOffset } = s;\n        if (!anchorNode || !focusNode)\n            throw 'error1';\n        // If the anchor and focus are the editor element, return either a full\n        // highlight or a start/end cursor position depending on the selection\n        if (anchorNode === editor && focusNode === editor) {\n            pos.start = (anchorOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.end = (focusOffset > 0 && editor.textContent) ? editor.textContent.length : 0;\n            pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';\n            return pos;\n        }\n        // Selection anchor and focus are expected to be text nodes,\n        // so normalize them.\n        if (anchorNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);\n            anchorNode = node;\n            anchorOffset = 0;\n        }\n        if (focusNode.nodeType === Node.ELEMENT_NODE) {\n            const node = document.createTextNode('');\n            focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);\n            focusNode = node;\n            focusOffset = 0;\n        }\n        visit(editor, el => {\n            if (el === anchorNode && el === focusNode) {\n                pos.start += anchorOffset;\n                pos.end += focusOffset;\n                pos.dir = anchorOffset <= focusOffset ? '->' : '<-';\n                return 'stop';\n            }\n            if (el === anchorNode) {\n                pos.start += anchorOffset;\n                if (!pos.dir) {\n                    pos.dir = '->';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            else if (el === focusNode) {\n                pos.end += focusOffset;\n                if (!pos.dir) {\n                    pos.dir = '<-';\n                }\n                else {\n                    return 'stop';\n                }\n            }\n            if (el.nodeType === Node.TEXT_NODE) {\n                if (pos.dir != '->')\n                    pos.start += el.nodeValue.length;\n                if (pos.dir != '<-')\n                    pos.end += el.nodeValue.length;\n            }\n        });\n        // collapse empty text nodes\n        editor.normalize();\n        return pos;\n    }\n    function restore(pos) {\n        const s = getSelection();\n        let startNode, startOffset = 0;\n        let endNode, endOffset = 0;\n        if (!pos.dir)\n            pos.dir = '->';\n        if (pos.start < 0)\n            pos.start = 0;\n        if (pos.end < 0)\n            pos.end = 0;\n        // Flip start and end if the direction reversed\n        if (pos.dir == '<-') {\n            const { start, end } = pos;\n            pos.start = end;\n            pos.end = start;\n        }\n        let current = 0;\n        visit(editor, el => {\n            if (el.nodeType !== Node.TEXT_NODE)\n                return;\n            const len = (el.nodeValue || '').length;\n            if (current + len > pos.start) {\n                if (!startNode) {\n                    startNode = el;\n                    startOffset = pos.start - current;\n                }\n                if (current + len > pos.end) {\n                    endNode = el;\n                    endOffset = pos.end - current;\n                    return 'stop';\n                }\n            }\n            current += len;\n        });\n        if (!startNode)\n            startNode = editor, startOffset = editor.childNodes.length;\n        if (!endNode)\n            endNode = editor, endOffset = editor.childNodes.length;\n        // Flip back the selection\n        if (pos.dir == '<-') {\n            [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];\n        }\n        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);\n    }\n    function beforeCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setEnd(r0.startContainer, r0.startOffset);\n        return r.toString();\n    }\n    function afterCursor() {\n        const s = getSelection();\n        const r0 = s.getRangeAt(0);\n        const r = document.createRange();\n        r.selectNodeContents(editor);\n        r.setStart(r0.endContainer, r0.endOffset);\n        return r.toString();\n    }\n    function handleNewLine(event) {\n        if (event.key === 'Enter') {\n            const before = beforeCursor();\n            const after = afterCursor();\n            let [padding] = findPadding(before);\n            let newLinePadding = padding;\n            // If last symbol is \"{\" ident new line\n            if (options.indentOn.test(before)) {\n                newLinePadding += options.tab;\n            }\n            // Preserve padding\n            if (newLinePadding.length > 0) {\n                preventDefault(event);\n                event.stopPropagation();\n                insert('\\n' + newLinePadding);\n            }\n            else {\n                legacyNewLineFix(event);\n            }\n            // Place adjacent \"}\" on next line\n            if (newLinePadding !== padding && options.moveToNewLine.test(after)) {\n                const pos = save();\n                insert('\\n' + padding);\n                restore(pos);\n            }\n        }\n    }\n    function legacyNewLineFix(event) {\n        // Firefox does not support plaintext-only mode\n        // and puts <div><br></div> on Enter. Let's help.\n        if (isLegacy && event.key === 'Enter') {\n            preventDefault(event);\n            event.stopPropagation();\n            if (afterCursor() == '') {\n                insert('\\n ');\n                const pos = save();\n                pos.start = --pos.end;\n                restore(pos);\n            }\n            else {\n                insert('\\n');\n            }\n        }\n    }\n    function handleSelfClosingCharacters(event) {\n        const open = `([{'\"`;\n        const close = `)]}'\"`;\n        const codeAfter = afterCursor();\n        const codeBefore = beforeCursor();\n        const escapeCharacter = codeBefore.substr(codeBefore.length - 1) === '\\\\';\n        const charAfter = codeAfter.substr(0, 1);\n        if (close.includes(event.key) && !escapeCharacter && charAfter === event.key) {\n            // We already have closing char next to cursor.\n            // Move one char to right.\n            const pos = save();\n            preventDefault(event);\n            pos.start = ++pos.end;\n            restore(pos);\n        }\n        else if (open.includes(event.key)\n            && !escapeCharacter\n            && (`\"'`.includes(event.key) || ['', ' ', '\\n'].includes(charAfter))) {\n            preventDefault(event);\n            const pos = save();\n            const wrapText = pos.start == pos.end ? '' : getSelection().toString();\n            const text = event.key + wrapText + close[open.indexOf(event.key)];\n            insert(text);\n            pos.start++;\n            pos.end++;\n            restore(pos);\n        }\n    }\n    function handleTabCharacters(event) {\n        if (event.key === 'Tab') {\n            preventDefault(event);\n            if (event.shiftKey) {\n                const before = beforeCursor();\n                let [padding, start,] = findPadding(before);\n                if (padding.length > 0) {\n                    const pos = save();\n                    // Remove full length tab or just remaining padding\n                    const len = Math.min(options.tab.length, padding.length);\n                    restore({ start, end: start + len });\n                    document.execCommand('delete');\n                    pos.start -= len;\n                    pos.end -= len;\n                    restore(pos);\n                }\n            }\n            else {\n                insert(options.tab);\n            }\n        }\n    }\n    function handleUndoRedo(event) {\n        if (isUndo(event)) {\n            preventDefault(event);\n            at--;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at < 0)\n                at = 0;\n        }\n        if (isRedo(event)) {\n            preventDefault(event);\n            at++;\n            const record = history[at];\n            if (record) {\n                editor.innerHTML = record.html;\n                restore(record.pos);\n            }\n            if (at >= history.length)\n                at--;\n        }\n    }\n    function recordHistory() {\n        if (!focus)\n            return;\n        const html = editor.innerHTML;\n        const pos = save();\n        const lastRecord = history[at];\n        if (lastRecord) {\n            if (lastRecord.html === html\n                && lastRecord.pos.start === pos.start\n                && lastRecord.pos.end === pos.end)\n                return;\n        }\n        at++;\n        history[at] = { html, pos };\n        history.splice(at + 1);\n        const maxHistory = 300;\n        if (at > maxHistory) {\n            at = maxHistory;\n            history.splice(0, 1);\n        }\n    }\n    function handlePaste(event) {\n        preventDefault(event);\n        const text = (event.originalEvent || event)\n            .clipboardData\n            .getData('text/plain')\n            .replace(/\\r/g, '');\n        const pos = save();\n        insert(text);\n        highlight(editor);\n        restore({\n            start: Math.min(pos.start, pos.end) + text.length,\n            end: Math.min(pos.start, pos.end) + text.length,\n            dir: '<-',\n        });\n    }\n    function visit(editor, visitor) {\n        const queue = [];\n        if (editor.firstChild)\n            queue.push(editor.firstChild);\n        let el = queue.pop();\n        while (el) {\n            if (visitor(el) === 'stop')\n                break;\n            if (el.nextSibling)\n                queue.push(el.nextSibling);\n            if (el.firstChild)\n                queue.push(el.firstChild);\n            el = queue.pop();\n        }\n    }\n    function isCtrl(event) {\n        return event.metaKey || event.ctrlKey;\n    }\n    function isUndo(event) {\n        return isCtrl(event) && !event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isRedo(event) {\n        return isCtrl(event) && event.shiftKey && getKeyCode(event) === 'Z';\n    }\n    function isCopy(event) {\n        return isCtrl(event) && getKeyCode(event) === 'C';\n    }\n    function getKeyCode(event) {\n        let key = event.key || event.keyCode || event.which;\n        if (!key)\n            return undefined;\n        return (typeof key === 'string' ? key : String.fromCharCode(key)).toUpperCase();\n    }\n    function insert(text) {\n        text = text\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n        document.execCommand('insertHTML', false, text);\n    }\n    function debounce(cb, wait) {\n        let timeout = 0;\n        return (...args) => {\n            clearTimeout(timeout);\n            timeout = window.setTimeout(() => cb(...args), wait);\n        };\n    }\n    function findPadding(text) {\n        // Find beginning of previous line.\n        let i = text.length - 1;\n        while (i >= 0 && text[i] !== '\\n')\n            i--;\n        i++;\n        // Find padding of the line.\n        let j = i;\n        while (j < text.length && /[ \\t]/.test(text[j]))\n            j++;\n        return [text.substring(i, j) || '', i, j];\n    }\n    function toString() {\n        return editor.textContent || '';\n    }\n    function preventDefault(event) {\n        event.preventDefault();\n    }\n    function getSelection() {\n        var _a;\n        if (((_a = editor.parentNode) === null || _a === void 0 ? void 0 : _a.nodeType) == Node.DOCUMENT_FRAGMENT_NODE) {\n            return editor.parentNode.getSelection();\n        }\n        return window.getSelection();\n    }\n    return {\n        updateOptions(newOptions) {\n            Object.assign(options, newOptions);\n        },\n        updateCode(code) {\n            editor.textContent = code;\n            highlight(editor);\n        },\n        onUpdate(cb) {\n            callback = cb;\n        },\n        toString,\n        save,\n        restore,\n        recordHistory,\n        destroy() {\n            for (let [type, fn] of listeners) {\n                editor.removeEventListener(type, fn);\n            }\n        },\n    };\n}\n"],
  "mappings": "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",
  "names": ["window", "editor"]
}
